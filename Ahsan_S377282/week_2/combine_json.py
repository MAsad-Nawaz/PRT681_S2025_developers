import json
import math # Import math to check for NaN values

# --- Config ---
# Path to the JSON generated by your sheet.py script
CURRENT_JSON_FILE = "survey_grouped_with_area.json"
# Path to the new JSON data you want to combine
OTHER_JSON_FILE = "review_grouped.json" # You might need to change this if your file has a different name
# Output path for the combined JSON
COMBINED_JSON_FILE = "combined_nematode_data.json"

# Define a mapping for scientific/specific nematode names to their common names
# This map will be applied to both datasets to ensure consistent common names
nematode_common_names_map = {
    "Meloidogyne sp.": "Root-knot",
    # Add more mappings if needed, e.g., "Xiphinema americanum": "Dagger Nematode",
}

# Define the target schema (columns) based on your current JSON's record structure
# Default values are set for fields that might be missing in the 'other' JSON
TARGET_RECORD_SCHEMA = {
    "Sample ID": "",
    "Sampling State": "",
    "Sampling Region": "",
    "Site Description": "",
    "Plant Associated": "",
    "Collected by": "",
    "Material": "",
    "lat": None,  # Use None for numerical fields that can be NaN/null
    "lng": None,  # Use None for numerical fields that can be NaN/null
    "area": "", # This 'area' is from the original script's area_names, not 'region'
    "common_nematode_name": "",
    "original_nematode_name": "",
    "sample_size": None # Use None for numerical fields that can be NaN/null
}

def load_json_file(filepath):
    """Loads a JSON file from the given filepath."""
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"Error: The file '{filepath}' was not found.")
        return None
    except json.JSONDecodeError:
        print(f"Error: Could not decode JSON from '{filepath}'. Check file format.")
        return None

def combine_nematode_data():
    """Combines two nematode JSON datasets into a single, structured JSON."""
    combined_data = {}

    # 1. Load the current JSON data
    current_data = load_json_file(CURRENT_JSON_FILE)
    if current_data is None:
        print(f"Could not load {CURRENT_JSON_FILE}. Exiting.")
        return

    # Initialize combined_data with the content of the current JSON
    # This ensures all existing data is carried over
    for common_name, records in current_data.items():
        combined_data[common_name] = records[:] # Use slice to create a shallow copy of the list

    # 2. Load the other JSON data
    other_data = load_json_file(OTHER_JSON_FILE)
    if other_data is None:
        print(f"Could not load {OTHER_JSON_FILE}. Exiting.")
        return

    # 3. Process and combine the 'other' JSON data
    for other_group_key, other_records in other_data.items():
        for other_record in other_records:
            # Create a new record based on the target schema defaults
            new_combined_record = TARGET_RECORD_SCHEMA.copy()

            # Map fields from the 'other' record to the target schema
            # Handle potential NaN values for lat/lng
            new_combined_record["lat"] = other_record.get("lat")
            if isinstance(new_combined_record["lat"], float) and math.isnan(new_combined_record["lat"]):
                new_combined_record["lat"] = None

            new_combined_record["lng"] = other_record.get("lng")
            if isinstance(new_combined_record["lng"], float) and math.isnan(new_combined_record["lng"]):
                new_combined_record["lng"] = None

            new_combined_record["Sampling Region"] = other_record.get("region", "")
            new_combined_record["Sampling State"] = other_record.get("state", "")

            # --- FIX for AttributeError: 'float' object has no attribute 'strip' ---
            plant_value = other_record.get("plant")
            if isinstance(plant_value, float) and math.isnan(plant_value):
                new_combined_record["Plant Associated"] = ""
            elif plant_value is None:
                new_combined_record["Plant Associated"] = ""
            else:
                new_combined_record["Plant Associated"] = str(plant_value).strip()
            # --- END FIX ---

            # The 'full_name' from the other JSON becomes the 'original_nematode_name'
            original_nem_name = other_record.get("full_name", "")
            new_combined_record["original_nematode_name"] = original_nem_name

            # Determine the common nematode name for grouping and the 'common_nematode_name' field
            # First, try to map the original_nem_name (e.g., "Meloidogyne sp.")
            common_nem_name = nematode_common_names_map.get(original_nem_name, original_nem_name)

            # If the original_nem_name didn't map, check if the group key itself maps
            # This handles cases where the group key is already a common name or a genus
            if common_nem_name == original_nem_name: # If no mapping happened for full_name
                 common_nem_name = nematode_common_names_map.get(other_group_key, other_group_key)


            new_combined_record["common_nematode_name"] = common_nem_name

            # Add the new_combined_record to the appropriate list in combined_data
            # Group by the 'common_nem_name'
            combined_data.setdefault(common_nem_name, []).append(new_combined_record)

    # 4. Write the combined JSON
    try:
        with open(COMBINED_JSON_FILE, "w", encoding="utf-8") as f:
            json.dump(combined_data, f, indent=2, ensure_ascii=False)
        total_records = sum(len(v) for v in combined_data.values())
        total_groups = len(combined_data)
        print(f"Successfully combined data into '{COMBINED_JSON_FILE}'.")
        print(f"Wrote {total_records} records across {total_groups} nematode groups.")
    except Exception as e:
        print(f"Error writing combined JSON to file: {e}")

# Run the combination process
if __name__ == "__main__":
    combine_nematode_data()